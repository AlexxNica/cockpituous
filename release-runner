#!/bin/sh -euf
#
# release-runner
#
# Runs a delivery script.
#
# The script is a shell script. Items in the script can be preceeded
# with the word 'job'. If so, they will get $RELEASE_XXX envars exported
# and asked to run transactionally.
#
# If a given script item can run transactionally, it will pause before
# making published, permanent changes ... and wait for all the other
# jobs to proceed. If all succeed, then they are all unpaused and
# allowed to continue to completion, one at a time.
#
# Arguments are described here. Most arguments have an equivalent envvar.
#
# -n                                Dry run, stop before publishing changes
# -q         RELEASE_QUIET=1        Make output more quiet
# -v         RELEASE_VERBOSE=1      Make output more verbose
#


set -euf

# We want job control
set -m

DRYRUN=0
JOBS=""

usage()
{
    echo "usage: release-runner [-nqv] SCRIPT" >&2
    exit ${1:-2}
}

trace()
{
    if [ ${RELEASE_QUIET:-0} -eq 0 ]; then
        echo "> $@" >&2
    fi
}

message()
{
    echo "release-runner: $@" >&2
}

job()
{
    local ret

    RELEASE_TARBALL=${RELEASE_TARBALL:-$PWD/tarball}
    RELEASE_SRPM=${RELEASE_SRPM:-$PWD/srpm}
    RELEASE_TRANSACTION=1

    # Export all RELEASE_XXXX variables
    eval $(set | sed -n 's/^\(RELEASE_[^=]\+\)=.*/export \1/p')

    trace "Starting: $@"

    # Run the task
    set +e
    "$@"
    ret=$?
    set -e

    if [ $ret -eq 0 ]; then
        trace "Done: $@"
        return 0 # completed successfully

    elif [ $ret -gt 128 -a $ret -lt 193 ]; then
        sig=$(kill -l $ret)
        if [ "$sig" = "STOP" ]; then
            trace "Ready: $@"
            return 0 # job not yet finished
        else
            message "terminated with $sig: $@"
        fi

    else
        message "failed code $ret: $@"
    fi

    exit $ret
}

while getopts "nqvx" opt; do
    case "$opt" in
    n)
        DRYRUN=1
        ;;
    q)
        RELEASE_QUIET=1
        RELEASE_VERBOSE=0
        ;;
    v)
        RELEASE_QUIET=0
        RELEASE_VERBOSE=1
        ;;
    -)
        break
        ;;
    *)
        usage
        ;;
    esac
done

PATH=$PATH:$(dirname $0)

shift $(expr $OPTIND - 1)

if [ $# -ne 1 ]; then
    usage
fi

# Run the basic script
. $1

if [ $DRYRUN -eq 1 ]; then
    exit 0
fi

# Run all the remaining background jobs
JOBS=$(jobs -l | sed 's/[^0-9]*\([0-9]\+\).*/\1/')
for job in $JOBS; do
    fg %$job
    trace "Completed job"
done
