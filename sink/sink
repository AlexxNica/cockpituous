#!/usr/bin/env python

# Rough configuration file follows, place it in ~/.config/sink

DEFAULTS = """
[Sink]
Url: http://fedorapeople.org/~%(user)s/logs
Logs: ~/public_html/logs

[GitHub]
Token:

[Irc]
Server: chat.freenode.net:6667
User: %(user)sbot
Password: %(user)sbot
Channel: #cockpit
"""

import argparse
import errno
import httplib
import json
import os
import shutil
import string
import subprocess
import sys
import tempfile
import urlparse

import ConfigParser
import StringIO

class GitHub(object):
    def __init__(self, config):
        self.token = config.get("GitHub", "Token")

    def push(self, status):
        github = status.get("github", { })
        resource = github.get("resource", None)
        data = github.get("status", None)
        if not self.token or not data or not resource:
            return
        if "target_url" not in data:
            data["target_url"] = status["link"]
        headers = {"Content-type": "application/json", "User-Agent": "Cockpit Tests" }
        if self.token:
            headers["Authorization"] = "token " + self.token
        conn = httplib.HTTPSConnection("api.github.com", strict=True)
        # conn.set_debuglevel(1)
        conn.request("POST", resource, json.dumps(data), headers)
        response = conn.getresponse()
        output = response.read()
        conn.close()
        if response.status < 200 or response.status >= 300:
            sys.stderr.write(output)
            raise Exception("GitHub API problem: {0}".format(response.reason or response.status))

class Irc(object):
    def __init__(self, config):
        pass

    def push(self, status):
        if True:
            return # TODO
        notify = status.get("notify")
        if not notify:
            return
        line = notify + " - " + status["link"] + "\n"
        proc = subprocess.Popen([ os.path.join(xxx, "irccat") ], stdin=subprocess.PIPE)
        proc.communicate(line)

class Status(object):
    def __init__(self, config, identifier):
        self.reporters = [ GitHub(config), Irc(config) ]
        self.link = urlparse.urljoin(config.get("Sink", "Url"), identifier + "/")
        self.data = None
        sys.stdout.write(self.link + "\n")
        sys.stdout.flush()

    def push(self, data):
        if "link" not in data:
            data["link"] = self.link
        for reporter in self.reporters:
            reporter.push(data)
        self.data = data

    def begin(self, line):
        try:
            data = json.loads(line)
        except:
            return False
        self.push(data)
        return True

    def finish(self, line):
        if not self.data:
            return False
        used = False
        try:
            data = json.loads(line)
            used = True
        except:
            data = self.data
            data["notify"] = "Aborted"
            if "github" in data and "status" in data["github"]:
                data["github"]["status"]["state"] = "error"
                data["github"]["status"]["description"] = "Aborted without status"
        self.push(data)
        with open("status", "w") as fp:
            fp.write(json.dumps(data))
        return used

class Buffer(object):
    def __init__(self, fd):
        self.fd = fd
        self.buf = ''
    def push(self, piece):
        self.buf = piece + self.buf
    def readall(self):
        self.read(sys.maxint)
    def read(self, n=sys.maxint):
        result = self.buf
        self.buf = ''
        while len(result) < n:
            want = n - len(result)
            data = os.read(self.fd, want > 1024 and 1024 or want)
            if not data:
                break
            result += data
        return result
    def readone(self):
        result = self.buf
        self.buf = ''
        result += os.read(self.fd, 1024)
        return result

def main():
    parser = argparse.ArgumentParser(description="Sink logs from distributed processes")
    parser.add_argument("identifier", nargs=1)
    parser.set_defaults(verbosity=1)
    args = parser.parse_args()

    valid_chars = "-_.%s%s" % (string.ascii_letters, string.digits, )
    identifier = "".join([c if c in valid_chars else '-' for c in args.identifier[0]])
    if not identifier or identifier != args.identifier[0]:
        parser.error("not a valid log identifier: " + identifier)

    # Load up configuration if available
    config = ConfigParser.SafeConfigParser({ "user": os.environ.get("LOGNAME", os.getlogin()) })
    config.readfp(StringIO.StringIO(DEFAULTS))
    config.read([ os.path.expanduser("~/.config/sink") ])

    # Create the right directory
    logs = os.path.expanduser(config.get("Sink", "Logs"))
    directory = os.path.join(logs, identifier)
    if os.path.exists(directory):
        files = os.listdir(directory)
        dest = tempfile.mkdtemp(prefix='backup.', dir=directory)
        os.chmod(dest, 0755)
        for filename in files:
            if not filename.startswith("backup."):
                shutil.move(os.path.join(directory, filename), dest)
    else:
        os.makedirs(directory)
    os.chdir(directory)

    # Initialize status reporters
    status = Status(config, identifier)

    # Now relay any data until zero byte
    buffer = Buffer(0)
    attached = False
    with open("log", "w") as log:
        count = 0          # Number of lines processed
        last = ""          # Last full output valid line
        done = False       # Set when done
        while not done:
            data = buffer.readone()
            if not data:
                done = True
            (text, unused, trailing) = (last + data).partition('\x00')
            if trailing:
                buffer.push(trailing)
                attached = True
                done = True
            if done and text and text[-1] == '\n':
                text = text[:-1]
            lines = text.split("\n")
            last = lines.pop()
            for line in lines:
                line += "\n"
                count += 1
                if count == 1:
                    if status.begin(line):
                        continue
                log.write(line)
                sys.stdout.write(line)
        if not status.finish(last):
            log.write(last)
            sys.stdout.write(line)

    if attached:
        with tarfile.open(fileobj=buffer, mode="r") as tar:
            tar.extractall()

if __name__ == "__main__":
    main()
