#!/usr/bin/env python

import argparse
import errno
import os
import shutil
import string
import StringIO
import subprocess
import sys
import tempfile

base = os.path.abspath(os.path.dirname(__file__))
logs = os.getenv("LOGS", os.path.join(base, "logs"))

parser = argparse.ArgumentParser(description="Sink logs from distributed processes")
parser.add_argument("-f", "--format", dest="format", help="Format of input")
parser.add_argument("-m", "--message", dest="message", help="Message to display")
parser.add_argument("identifier", nargs=1)

parser.set_defaults(verbosity=1)
args = parser.parse_args()

# Now process the remaining
if args.format == "gz":
    cmd = os.path.join(base, "gzplit")
elif args.format == "tar":
    cmd = os.path.join(base, "tarsplit")
elif args.format:
    parser.error("unsupported format: " + args.format)
else:
    cmd = "/usr/bin/cat"

valid_chars = "-_.%s%s" % (string.ascii_letters, string.digits, )
identifier = "".join([c if c in valid_chars else '-' for c in args.identifier[0]])
if not identifier or identifier != args.identifier[0]:
    parser.error("not a valid log identifier: " + identifier)

backup = False
directory = os.path.join(logs, identifier)

if os.path.exists(directory):
    backup = True
else:
    os.makedirs(directory)
os.chdir(directory)

# Backup all the older files if necessary
if backup:
    files = os.listdir(directory)
    dest = tempfile.mkdtemp(prefix='backup.', dir=".")
    os.chmod(dest, 0755)
    for filename in files:
        if not os.path.isdir(filename):
            shutil.move(filename, dest)

# Open output file in the directory

# Send the output name
link = "http://logs.cockpit-project.org/logs/" + identifier + "/"
sys.stdout.write(link + "\n")
sys.stdout.flush()

# Tell IRC that we're working on this
line = args.message or "Running" + " - " + link + "\n"
proc = subprocess.Popen([ os.path.join(base, "irccat") ], stdin=subprocess.PIPE)
proc.communicate(line)

# Now open up the parser and tee its output into the log
parser = subprocess.Popen([ cmd ], stdout=subprocess.PIPE)
tee = subprocess.Popen([ "tee", "-a", "log" ], stdin=parser.stdout)
parser.stdout.close()
sys.exit(parser.wait())
