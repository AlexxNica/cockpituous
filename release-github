#!/bin/sh -euf

set -euf

# Arguments
VERBOSE="${RELEASE_VERBOSE:-0}"
QUIET="${RELEASE_QUIET:-0}"
TRANSACTION="${RELEASE_TRANSACTION:-1}"
ORIGIN="${RELEASE_ORIGIN:-origin}"
TARBALL="${RELEASE_TARBALL:-$PWD/.tarball}"
TAG="${RELEASE_TAG:-}"

# Other globals
TOKEN="${GITHUB_TOKEN:-}"
REPO=
RELEASE=
CLEANUP=

usage()
{
    echo "usage: release-github [-qvx] [-t TAG] [-o ORIGIN] [-f TARBALL]" >&2
    exit ${1-2}
}

trace()
{
    if [ $QUIET -eq 0 ]; then
        message "$@"
    fi
}

message()
{
    echo "release-github: $@" >&2
}

json_escape()
{
    # Escape quotes, backslashes and new lines
    sed -e 's/[\\"]/\\\0/g' -e 's/$/\\n/g'
}

trim_contents()
{
    # Remove line with just tag name. Remove signature
    sed -e '/^\s*'$TAG'\s*$/d' -e '/-----BEGIN/,/-----END/d'
}

run_curl()
{
    local arg

    if [ $VERBOSE -eq 1 ]; then
        arg="--verbose"
    elif [ $QUIET -eq 1 ]; then
        arg="-s"
    else
        arg=""
    fi

    if ! curl $arg -S --fail -H "Authorization: token $TOKEN" "$@"; then
        message "github api call failed"
        exit 1
    fi
}

prepare()
{
    local tmpfile body upload uplog base progress

    tmpfile=$(mktemp .github-draft.XXXXXX.json)

    # The body of the email ready as a JSON string
    body="$(git for-each-ref --format='%(contents)' "refs/tags/$TAG" | trim_contents | json_escape)"

    trace "creating release draft: $TAG"

    # Create the release via the Github API
    printf '{"tag_name": "%s", "name": "%s", "draft": true, "body": "%s" }\n' "$TAG" "$TAG" "$body" |
        run_curl -s --data @- --output $tmpfile https://api.github.com$REPO/releases

    # Remove this file later
    CLEANUP="$CLEANUP $tmpfile"

    # The release URL for later commit
    RELEASE=$(sed -n 's/.*"url"\s*:\s*"\([^"]*\).*/\1/p' $tmpfile | head -n 1)

    if [ -n "$TARBALL" ]; then
        trace "uploading file: $TARBALL"

        # Figure out the URL to upload to
        upload=$(sed -n 's/.*"upload_url"\s*:\s*"\([^{"]*\).*/\1/p' $tmpfile)

        # And do the actual upload via the Github API
        uplog=$(mktemp .github-upload.XXXXXX.json)

        if [ -n "$QUIET" ]; then
            progress="--progress-bar"
        fi

        ball="$(readlink $TARBALL)"
        base="$(basename $ball)"
        run_curl --data-binary @$TARBALL --progress-bar --output $uplog \
             -H "Accept: application/vnd.github.manifold-preview" \
             -H "Content-Type: application/x-bz2" \
            "$upload?name=$base"

        # Remove this file later
        CLEANUP="$CLEANUP $uplog"
    fi
}

commit()
{
    tmpfile=$(mktemp .github-publish.XXXXXX.json)

    trace "publishing draft: $TAG"

    printf '{"draft": false}\n' |
        run_curl -s --data @- --output $tmpfile --request PATCH $RELEASE

    # Remove all the temporary files on success
    rm $CLEANUP $tmpfile
}

while getopts "f:o:t:qvx" opt; do
    case "$opt" in
    f)
        TARBALL="$OPTARG"
        ;;
    o)
        ORIGIN="$OPTARG"
        ;;
    t)
        TAG="$OPTARG"
        ;;
    q)
        QUIET=1
        VERBOSE=0
        ;;
    v)
        VERBOSE=1
        QUIET=0
        ;;
    x)
        TRANSACTION=1
        ;;
    -)
        break
        ;;
    *)
        usage 0
        ;;
    esac
done

shift $(expr $OPTIND - 1)

if [ $# -ne 0 ]; then
    usage
fi

# A github.com repos path like /repos/:ownser/:repo
REPO=$(LC_ALL=C git remote show -n $ORIGIN |
    sed -n 's/.*Push.*github.com[:\/]\(.*\+\)\/\([^\.]\+\).*/\/repos\/\1\/\2/p')

if [ -z "$REPO" ]; then
    message "could not find github remote: $ORIGIN"
    exit 1
fi

# The tag for the release
if [ -z "$TAG" ]; then
    TAG=$(git describe --abbrev=0)
    if [ -z "$TAG" ]; then
        message "could not find a tag to release"
        exit 1
    fi
fi

# And finally the token for access
if [ -z "$TOKEN" ]; then
    TOKEN=$(cat ~/.config/github-token)
fi

prepare

if [ $TRANSACTION -eq 1 ]; then
    kill -STOP $$
fi

commit
